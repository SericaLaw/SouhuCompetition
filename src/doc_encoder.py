import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import os
SAVE_INFO_PATH = "./model/saveInfo"


class PassageEncoder(nn.Module):
    def __init__(self, input_size, output_size):
        '''
        initial encoder
        :param input_size: input size of lstm
        :param output_size:  output size of lstm
        '''
        super(PassageEncoder,self).__init__()
        self.bilstm = nn.LSTM(input_size=input_size,hidden_size=output_size,
                              dropout=0.33,bidirectional=True)

    def forward(self, feature, input_length, hidden=None):
        '''
        :param feature: torch tensor of shape(batch_size, )
        :param input_length: length of input, torch tensor of dtype int
        :param hidden: initial hidden state, torch tensor shape(output_size)
        :return: the output of lstm of shape(batch_size, length, output_size)
        '''
        packed = nn.utils.rnn.pack_padded_sequence(feature, batch_first=True, lengths=input_length)
        lstm_out,hidden = self.bilstm(packed, hidden)
        out = nn.utils.rnn.pad_packed_sequence(lstm_out,batch_first=True)
        return out


def load_model(path, hidden_size=10, version="last"):
    model = PassageEncoder(hidden_size,hidden_size)
    if not os.path.exists(path):
        print("not exist")
        return model
    else:
        saveinfo = torch.load(SAVE_INFO_PATH)[version]
        model.load_state_dict(torch.load(saveinfo)["model_state_dict"])
        cur_epoch = torch.load(saveinfo["epoch"])
        return model, cur_epoch


def aggregate_title_content(self, title, content):
    '''
    aggregate title and content to form passage vector
    here just cat content after title
    :param title: torch tensor of shape (title_len, d)
    :param content: torch tensor of shape (content_len, d)
    :return: aggregated passage tensor of shape(title_len+content_len, d)
    '''
    passage = torch.cat([title,content],dim=0)
    return passage


def loss_fn(encoded_passage, label, entity_candidate):
    '''
    triplet loss with anchor as encoded_passage, positive as label, negtive as entity_candidate
    :param encoded_passage: output of lstm with shape (batch_size, seq_length, num_layer, output_size)
    :param label: a batch_size length list of dict contain the passage label of 3 entity
    :param entity_candidate: a batch_size length list of dict contain negative entity generated by tf-idf
    :return: loss
    '''
    print(encoded_passage[1,-1,:].shape)
    total_loss = torch.zeros(1,dtype=torch.float)
    for i_batch in range(encoded_passage.shape[0]):
        for entity_name, entity_value in label[i_batch].items():
            for candidate_name, candidate_value in entity_candidate[i_batch].items():
                total_loss += nn.functional.triplet_margin_loss(
                    anchor=encoded_passage[i_batch][-1,:], positive=entity_value, negative=candidate_value
                )
    return total_loss


def getdata(dataloader):
    return dataloader


def train(dataloader, model, num_epcoh=1, lr=0.1, save_path=None):
    epoch = model[1]
    model = model[0]
    model.train()
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    for step in range(num_epcoh):
        # for idx, data in enumerate(dataloader):
        optimizer.zero_grad()
        data = getdata(dataloader)
        passage, length, label, candidate = data["passage"], data["length"], data["entity"], data["candidate"]
        encoded_passage, _ = model(passage, length)
        shape = encoded_passage.shape
        encoded_passage = encoded_passage.view(shape[0],shape[1],2,-1)
        loss = loss_fn(encoded_passage, label, candidate)
        loss.backward()
        optimizer.step()
        epoch += 1
        if not save_path:
            torch.save({"model_state_dict":model.state_dict(),
                        "epoch": epoch},save_path)


def eval(dataloader, model):
    model = model[0]
    model.eval()
    data = getdata(dataloader)
    passage, length, label, candidate = data["passage"], data["length"], data["entity"], data["candidate"]
    encoded_passage, _ = model(passage, length)
    shape = encoded_passage.shape
    encoded_passage = encoded_passage.view(shape[0], shape[1], 2, -1)
    loss = loss_fn(encoded_passage, label, candidate)
    print(loss)



def stackpassage(passages):
    '''

    :param passages:
    :return: passages sorted by length
    '''
    passages.sort(key=lambda x:x["length"],reverse=True)
    dataset = {}
    for key in passages[0]:
        dataset[key] = []
        for p in passages:
            dataset[key].append(p[key])
    dataset["passage"] = nn.utils.rnn.pad_sequence(dataset["passage"],batch_first=True)
    return dataset


def test():
    nd = 10
    passages = []
    for i in range(3):
        passage = {}
        # passage["title"] = torch.randn(size=(1+i,nd))
        # passage["content"] = torch.randn(size=(2+i,nd))
        passage["passage"] = torch.randn(size=(2+i, nd))
        passage["length"] = 2+i
        passage["entity"] = {"a":torch.randn(size=(nd,)),
                             "b":torch.randn(size=(nd,)),
                             "c": torch.randn(size=(nd,))}
        passage["candidate"] = {"a":torch.randn(size=(nd,)),
                                "e": torch.randn(size=(nd,)),
                                "b": torch.randn(size=(nd,)),
                                "f": torch.randn(size=(nd,))}
        passages.append(passage)
    # dataset = PassageDataset(passages)
    # dataloader = DataLoader(dataset,2, True,collate_fn=collate_wrapper, pin_memory=True)
    dataloader = stackpassage(passages)
    model = PassageEncoder(nd, nd)
    train(dataloader,model)


if __name__ == "__main__":
    # test()
    load_model(SAVE_INFO_PATH,10)